<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>All Taluks - Uttara Kannada</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
  <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
  <link rel="icon" type="image/png" href="assets/icons/favicon.png">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="css/style.css">
  <link rel="stylesheet" href="css/glass-nav.css">
</head>

<body class="bg-gray-50">
  <header class="header glass-header">
    <div class="container nav glass-pill">
      <div class="logo-wrapper">
        <img src="assets/icons/favicon.png" height="36px" width="36px" alt="Namma UK Logo">
        <a href="index.html" class="logo text-lg font-bold text-white tracking-wide" data-i18n="app_title">Uttara
          Kannada</a>
      </div>
      <div class="flex items-center gap-4">
        <button onclick="history.back()" class="glass-back-btn"><i class="fa-solid fa-arrow-left"></i> <span
            data-i18n="btn_back">Back</span></button>
        <nav class="nav-links hidden md:flex gap-2">
          <a href="index.html" class="glass-back-btn" style="border:none; background:transparent;"
            data-i18n="btn_home">Home</a>
          <a href="about.html" class="glass-back-btn" style="border:none; background:transparent;"
            data-i18n="nav_about">About</a>
        </nav>
      </div>
    </div>
  </header>

  <main>
    <section class="sub-header" data-aos="fade-down"
      style="background: linear-gradient(135deg, #115e59 0%, #0d9488 50%, #14b8a6 100%); padding-top: 10rem; padding-bottom: 4rem; color: white;">
      <div class="container">
        <h1 style="color: white; font-size: 2.5rem; font-weight: 800; text-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);"
          data-i18n="taluks_title">
          Taluks of Uttara Kannada</h1>
        <p class="text-muted" style="color: rgba(255, 255, 255, 0.9); font-size: 1.1rem;" data-i18n="taluks_sub">Click a
          taluk to view its
          tourist places</p>
      </div>
    </section>

    <section class="py-6">
      <div class="container">
        <div class="controls" data-aos="fade-up">
          <div class="control-card" style="display:flex;gap:12px;align-items:center;">
            <label for="search" class="sr-only">Search taluk or place</label>
            <div style="flex:1;display:flex;align-items:center;gap:8px;">
              <i class="fa-solid fa-magnifying-glass" style="color:rgba(15,23,42,0.35)"></i>
              <input id="search" placeholder="Search taluk or place" class="search-input"
                data-i18n="search_placeholder" />
            </div>
            <button id="useLocationBtn" class="btn" title="Use my location"
              style="white-space:nowrap;background:#fff;color:#0891b2;border:1px solid #e6eef8"><i
                class="fa-solid fa-location-crosshairs"></i>&nbsp;<span>Use my location</span></button>
            <button id="manualLocationBtn" class="btn" title="Enter location manually"
              style="white-space:nowrap;background:#fff;color:#111;border:1px solid #e6eef8"><i
                class="fa-solid fa-keyboard"></i>&nbsp;<span>Enter location</span></button>
            <div style="display:flex;align-items:center;gap:8px">
              <label class="small" style="margin-right:6px">Trip:</label>
              <select id="tripDays" class="lang-dropdown" style="min-width:84px;padding:6px 10px">
                <option value="1">1 day</option>
                <option value="2">2 day</option>
                <option value="3">3 day</option>
              </select>
            </div>
            <div id="planTripQuick" class="small"
              style="cursor:pointer;font-weight:700;color:#075985;display:flex;align-items:center;gap:8px"><i
                class="fa-solid fa-calendar-days"></i><span>Plan trip</span></div>
          </div>
        </div>
        <div id="manualLocationPanel" class="manual-panel hidden" style="margin-top:10px">
          <div style="display:flex;gap:8px;align-items:center">
            <input id="manualLocationInput" placeholder="Enter taluk/place or lat,lng (e.g. 14.61,74.55)"
              class="search-input" />
            <button id="manualLocateBtn" class="btn" style="white-space:nowrap;background:#06b6d4;color:#fff"><i
                class="fa-solid fa-location-dot"></i>&nbsp;<span>Locate nearby</span></button>
            <button id="manualCancelBtn" class="btn"
              style="white-space:nowrap;background:#fff;color:#111;border:1px solid #e6eef8">Cancel</button>
          </div>
          <div id="manualLocateMsg" class="small" style="margin-top:8px;color:#b91c1c;display:none"></div>
        </div>

        <!-- Trip planner modal -->
        <div id="tripModal" class="modal hidden" aria-hidden="true">
          <div id="tripBackdrop" class="modal-backdrop"></div>
          <div class="modal-content container">
            <button id="tripClose" class="btn"
              style="position:absolute;right:14px;top:14px;z-index:3000;border-radius:999px;padding:8px;background:#fff;color:#111"><i
                class="fa-solid fa-xmark"></i></button>
            <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:8px">
              <div class="small">Planned trip</div>
              <div id="tripSummary" class="small text-muted" style="margin-left:6px"></div>
              <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
                <button id="tripExitBtn" class="btn"
                  style="background:#fff;color:#111;border:1px solid #e6eef8;padding:8px 12px">Exit map</button>
              </div>
            </div>
            <div class="modal-scroll-area">
              <div id="trip-map" style="width:100%;height:65vh;border-radius:12px;overflow:hidden"></div>
              <div id="trip-list" style="padding:10px 0;max-height:220px;overflow:auto"></div>
            </div>
            <div style="display:flex;justify-content:flex-end;margin-top:8px">
              <button id="openGMapsBtn" class="btn"
                style="background:linear-gradient(135deg,#1a73e8,#1967d2);border:none">Go to map</button>
            </div>
          </div>
        </div>
        <div id="talukGrid" class="taluk-list mt-4">
          <!-- cards inserted here -->
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container">
      <small class="text-muted" data-i18n="footer_text">&copy; <span id="currentYear"></span> NammaUK</small>
    </div>
  </footer>

  <!-- Nearby modal (hidden by default) -->
  <div id="nearbyModal" class="modal hidden" aria-hidden="true">
    <div id="nearbyBackdrop" class="modal-backdrop"></div>
    <div class="modal-content container">
      <button id="nearbyClose" class="btn" type="button"
        style="position:absolute;right:14px;top:14px;border-radius:999px;padding:8px;background:#fff;color:#111"><i
          class="fa-solid fa-xmark"></i></button>
      <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px">
        <h3 style="margin:0">Nearby places</h3>
        <div id="nearbyCount" class="small text-muted"></div>
        <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
          <button id="nearbyPlanBtn" class="btn"
            style="background:linear-gradient(135deg,#0891b2,#06b6d4);color:#fff;padding:8px 12px;border-radius:10px;border:none">Plan
            trip</button>
        </div>
      </div>
      <!-- <div id="nearby-map" style="width:100%;height:70vh;border-radius:12px;overflow:hidden"></div> -->
      <div class="modal-scroll-area">
        <div id="nearby-map" style="width:100%;height:70vh;border-radius:12px;overflow:hidden"></div>
        <div id="nearby-list" style="padding:10px 0;max-height:220px;overflow:auto"></div>
      </div>
    </div>
  </div>

  <script src="js/translations.js"></script>


  <script>
    // Initialize AOS
    AOS.init({
      duration: 800,
      once: true,
      offset: 100
    });

    function resolveImage(img) { if (!img) return 'https://via.placeholder.com/400x240?text=No+Image'; if (/^https?:\/\//i.test(img)) return img; return 'assets/images/' + img }
    Promise.all([
      fetch('data/places.json?v=' + Date.now()).then(r => r.json()),
      fetch('data/images.json?v=' + Date.now()).then(r => r.json())
    ])
      .then(([placesData, imagesData]) => {
        const container = document.getElementById('talukGrid');

        // Build image map
        const imageMap = {};
        Object.keys(imagesData).forEach(taluk => {
          const places = imagesData[taluk] || [];
          places.forEach(p => {
            if (p.name && p.image) {
              imageMap[p.name.toLowerCase()] = p.image;
            }
          });
        });

        const taluks = Object.keys(placesData).sort();
        // Render Function
        function renderTaluks() {
          container.innerHTML = '';
          const lang = window.currentLanguage || localStorage.getItem('uk_lang') || 'en';

          taluks.forEach((tk, index) => {
            const places = placesData[tk] || [];
            const count = places.length;

            // Try to find an image for the first place in the taluk
            let img = 'https://via.placeholder.com/400x240?text=' + encodeURIComponent(tk);
            if (places.length > 0) {
              const firstPlaceName = places[0].name.toLowerCase();
              if (imageMap[firstPlaceName]) {
                img = imageMap[firstPlaceName];
              } else if (places[0].image && /^https?:\/\//i.test(places[0].image)) {
                img = places[0].image;
              }
            }

            // Translate Taluk Name
            let displayName = tk;
            const talukKey = 'taluk_' + tk.toLowerCase();
            if (translations[lang] && translations[lang][talukKey]) {
              displayName = translations[lang][talukKey];
            }

            const a = document.createElement('a');
            a.className = 'taluk-card';
            a.href = tk.toLowerCase() + '.html';
            a.setAttribute('data-aos', 'fade-up');
            a.setAttribute('data-aos-delay', (index % 4) * 100);
            a.innerHTML = `
                <div class="taluk-card-image">
                  <img src="${img}" alt="${tk}" />
                  <span class="taluk-card-badge">${count} ${count === 1 ? 'Place' : 'Places'}</span>
                </div>
                <div class="taluk-card-content">
                  <h3>${displayName}</h3>
                  <!-- <p>${count} place${count !== 1 ? 's' : ''}</p> -->
                </div>
              `;
            container.appendChild(a);
          });
          AOS.refresh();
        }

        renderTaluks();

        // Listen for language changes
        window.addEventListener('languageChanged', (e) => {
          renderTaluks();
        });

        // search
        const searchEl = document.getElementById('search');
        searchEl.addEventListener('input', (e) => {
          const q = e.target.value.toLowerCase();
          Array.from(container.children).forEach(card => {
            // Search both English key (href) and visible text
            const href = card.getAttribute('href').replace('.html', '').toLowerCase();
            const text = card.textContent.toLowerCase();
            if (href.includes(q) || text.includes(q)) {
              card.style.display = 'block';
              // Fix for AOS compatibility: ensure element is visible
              card.style.opacity = '1';
              card.style.visibility = 'visible';
            } else {
              card.style.display = 'none';
            }
          });
          // Refresh AOS layout updates
          setTimeout(() => AOS.refresh(), 100);
        });

        // Build flat list of places for nearby calculations
        // Include entries even if coordinates exist but are flagged (e.g. coords_flagged:true)
        // Flagged places will be treated as name-preferred (no lat/lng) so the UI will geocode by name.
        const allPlaces = [];
        Object.keys(placesData).forEach(tk => {
          (placesData[tk] || []).forEach(p => {
            if (!p) return;
            const flagged = !!(p.coords_flagged || p.use_name || p.prefer_name || p.force_name);
            const entry = Object.assign({ taluk: tk, flagged: flagged }, p);
            if (entry.flagged) {
              // Remove coordinates client-side so downstream logic knows to prefer name/geocoding
              delete entry.lat;
              delete entry.lng;
            }
            allPlaces.push(entry);
          });
        });

        // Nearby modal and map logic
        let nearbyMap = null;
        let nearbyLayer = null;

        // Close helpers
        function closeNearby() {

          const modalEl = document.getElementById('nearbyModal');
          modalEl.classList.add('hidden');
          if (nearbyMap) { nearbyMap.remove(); nearbyMap = null; }
          document.removeEventListener('keydown', onEsc);
        }

        function onEsc(e) { if (e.key === 'Escape') closeNearby(); }
        document.getElementById('nearbyClose').addEventListener('click', closeNearby);

        function kmDistance(lat1, lon1, lat2, lon2) {
          const R = 6371; // km
          const dLat = (lat2 - lat1) * Math.PI / 180;
          const dLon = (lon2 - lon1) * Math.PI / 180;
          const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return R * c;
        }

        function openNearbyModal(userLatLng, startTaluk) {
          const modal = document.getElementById('nearbyModal');
          modal.classList.remove('hidden');

          // initialize map once
          if (!nearbyMap) {
            nearbyMap = L.map('nearby-map', { scrollWheelZoom: true }).setView([userLatLng.lat, userLatLng.lng], 10);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 20 }).addTo(nearbyMap);
            nearbyLayer = L.layerGroup().addTo(nearbyMap);
          } else {
            nearbyMap.invalidateSize();
            nearbyMap.setView([userLatLng.lat, userLatLng.lng], 10);
            nearbyLayer.clearLayers();
          }

          // Add user marker
          const userMarker = L.circleMarker([userLatLng.lat, userLatLng.lng], { radius: 8, color: '#075985', fillColor: '#06b6d4', fillOpacity: 0.9 }).addTo(nearbyLayer);
          L.circle([userLatLng.lat, userLatLng.lng], { radius: 1500, color: '#06b6d4', weight: 1, fill: false }).addTo(nearbyLayer);

          // find nearest places; compute distance only for entries that have coordinates
          const scored = allPlaces.map(p => {
            let dist = Infinity;
            if (p.lat !== undefined && p.lng !== undefined && p.lat !== null && p.lng !== null) {
              dist = kmDistance(userLatLng.lat, userLatLng.lng, p.lat, p.lng);
            }
            return { place: p, dist };
          });
          let nearby;
          if (startTaluk) {
            const same = scored.filter(s => (s.place.taluk || '').toLowerCase() === startTaluk.toLowerCase()).sort((a, b) => a.dist - b.dist);
            const others = scored.filter(s => (s.place.taluk || '').toLowerCase() !== startTaluk.toLowerCase()).sort((a, b) => a.dist - b.dist);
            nearby = same.concat(others).slice(0, 8);
          } else {
            nearby = scored.sort((a, b) => a.dist - b.dist).slice(0, 8);
          }

          const latlngs = [[userLatLng.lat, userLatLng.lng]];
          nearby.forEach((n, idx) => {
            const p = n.place;
            // add marker only if we have coordinates for the place
            if (p.lat !== undefined && p.lng !== undefined && p.lat !== null && p.lng !== null) {
              L.marker([p.lat, p.lng]).bindPopup(`<strong>${p.name}</strong><div class='small'>${p.taluk} • ${p.type || ''} • ${n.dist === Infinity ? '-' : n.dist.toFixed(1) + ' km'}</div>`).addTo(nearbyLayer);
              latlngs.push([p.lat, p.lng]);
            }
          });

          // draw route polyline only if we have at least one place with coordinates
          let route = null;
          if (latlngs.length > 1) {
            route = L.polyline(latlngs, { color: '#0891b2', weight: 4, opacity: 0.9 }).addTo(nearbyLayer);
            nearbyMap.fitBounds(route.getBounds().pad(0.3));
          } else {
            nearbyMap.setView([userLatLng.lat, userLatLng.lng], 12);
          }
          // ensure tiles render correctly after modal open
          setTimeout(() => { try { nearbyMap.invalidateSize(); } catch (e) { } }, 200);

          // allow Esc to close
          document.addEventListener('keydown', onEsc);

          // populate list and update count
          const countEl = document.getElementById('nearbyCount');
          if (countEl) countEl.textContent = `${nearby.length} nearby`;
          const list = document.getElementById('nearby-list');
          list.innerHTML = nearby.map((n, i) => `
            <div style="padding:10px;border-bottom:1px solid #f1f5f9">
              <strong>${n.place.name}</strong>
              <div class="small">${n.place.taluk} • ${n.place.type || ''} • ${n.dist === Infinity ? '-' : n.dist.toFixed(1) + ' km'}</div>
            </div>
          `).join('');
          // record modal's start location and taluk so the Plan button can reuse it
          window._nearbyStartLatLng = { lat: userLatLng.lat, lng: userLatLng.lng };
          window._nearbyStartTaluk = startTaluk || null;
        }

        // Button handlers
        document.getElementById('useLocationBtn').addEventListener('click', async () => {
          if (!navigator.geolocation) return alert('Geolocation not supported in this browser');
          // quick user-agent log to help debug mobile issues
          console.log('Geolocation requested, UA=', navigator.userAgent || 'unknown');

          // If Permissions API available, check geolocation permission first
          try {
            if (navigator.permissions && navigator.permissions.query) {
              const p = await navigator.permissions.query({ name: 'geolocation' });
              if (p.state === 'denied') {
                alert('Location access is denied. Enable location permission for this site in your browser settings and retry.');
                return;
              }
            }
          } catch (e) {
            // ignore permission check failures
            console.warn('Permissions check failed', e);
          }

          const geoOpts = { timeout: 15000, maximumAge: 0, enableHighAccuracy: true };
          navigator.geolocation.getCurrentPosition(pos => {
            openNearbyModal({ lat: pos.coords.latitude, lng: pos.coords.longitude });
          }, (err) => {
            // Show manual input panel if geolocation fails and display helpful message
            const panel = document.getElementById('manualLocationPanel');
            panel.classList.remove('hidden');
            document.getElementById('manualLocationInput').focus();
            console.warn('Geolocation failed:', err);
            const msgEl = document.getElementById('manualLocateMsg');
            if (msgEl) {
              let text = 'Unable to get location. ';
              if (err && err.code) {
                switch (err.code) {
                  case 1: text += 'Permission denied. Please allow location access.'; break;
                  case 2: text += 'Position unavailable.'; break;
                  case 3: text += 'Timeout obtaining location. Try again or enter location manually.'; break;
                  default: text += err.message || 'Unknown error.'; break;
                }
              }
              msgEl.textContent = text;
              msgEl.style.display = 'block';
            }
          }, geoOpts);
        });

        // Manual location panel handlers
        document.getElementById('manualLocationBtn').addEventListener('click', () => {
          const panel = document.getElementById('manualLocationPanel');
          panel.classList.toggle('hidden');
          if (!panel.classList.contains('hidden')) document.getElementById('manualLocationInput').focus();
        });

        document.getElementById('manualCancelBtn').addEventListener('click', () => {
          document.getElementById('manualLocationPanel').classList.add('hidden');
        });

        document.getElementById('manualLocateBtn').addEventListener('click', async () => {
          const q = document.getElementById('manualLocationInput').value.trim();
          const msgEl = document.getElementById('manualLocateMsg');
          msgEl.style.display = 'none';
          msgEl.textContent = '';
          if (!q) {
            msgEl.textContent = 'Please enter a taluk, place name, or lat,lng.';
            msgEl.style.display = 'block';
            return;
          }

          const btn = document.getElementById('manualLocateBtn');
          btn.disabled = true;
          const originalText = btn.textContent;
          btn.textContent = 'Locating...';

          // lat,lng format
          const numericMatch = q.match(/(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)/);
          if (numericMatch) {
            const lat = parseFloat(numericMatch[1]);
            const lng = parseFloat(numericMatch[2]);
            openNearbyModal({ lat, lng });
            document.getElementById('manualLocationPanel').classList.add('hidden');
            btn.disabled = false;
            btn.textContent = originalText;
            return;
          }

          // Try to resolve as taluk or place name (reuse findNearby logic)
          let loc = null;
          const talukKey = Object.keys(placesData).find(k => k.toLowerCase() === q.toLowerCase() || k.toLowerCase().includes(q.toLowerCase()));
          if (talukKey) {
            const place = (placesData[talukKey] || []).find(pp => pp.lat && pp.lng);
            if (place) loc = { lat: place.lat, lng: place.lng };
          }
          if (!loc) {
            for (const tk of Object.keys(placesData)) {
              const found = (placesData[tk] || []).find(pp => pp.name && pp.name.toLowerCase().includes(q.toLowerCase()) && pp.lat && pp.lng);
              if (found) { loc = { lat: found.lat, lng: found.lng }; break; }
            }
          }

          if (loc) {
            openNearbyModal(loc, talukKey);
            document.getElementById('manualLocationPanel').classList.add('hidden');
            btn.disabled = false;
            btn.textContent = originalText;
            return;
          }

          // Fallback: try online geocoding using OpenStreetMap Nominatim
          try {
            msgEl.textContent = 'Not found locally — trying online geocoding...';
            msgEl.style.display = 'block';
            const url = 'https://nominatim.openstreetmap.org/search?format=json&limit=3&countrycodes=in&q=' + encodeURIComponent(q);
            const res = await fetch(url, { headers: { 'Accept-Language': 'en' } });
            const data = await res.json();
            if (Array.isArray(data) && data.length > 0) {
              const first = data[0];
              const lat = parseFloat(first.lat);
              const lng = parseFloat(first.lon);
              msgEl.textContent = `Resolved via online geocoding: ${first.display_name}`;
              openNearbyModal({ lat, lng });
              document.getElementById('manualLocationPanel').classList.add('hidden');
            } else {
              msgEl.textContent = 'Could not resolve that location. Try a taluk name, place name, or lat,lng.';
            }
          } catch (err) {
            console.warn('Geocoding error', err);
            msgEl.textContent = 'Online geocoding failed. Try a taluk name, place name, or lat,lng.';
          }

          btn.disabled = false;
          btn.textContent = originalText;
        });

        // Trip planner logic
        function makeNumberedIcon(n) {
          return L.divIcon({
            className: 'num-icon',
            html: `<div class="num-badge">${n}</div>`,
            iconSize: [28, 28],
            iconAnchor: [14, 28]
          });
        }

        let tripCloseFn = null;

        async function planTripFrom(startLatLng, dayCount, startTaluk) {
          // stops per day approximate
          const stopsTotal = Math.min(allPlaces.length, dayCount * 4);
          const unvisited = allPlaces.slice();
          const route = [];
          let cur = { lat: startLatLng.lat, lng: startLatLng.lng };

          // Note: do not pre-geocode all flagged places here — that can block the UI.
          // We'll geocode route entries asynchronously later so the modal opens immediately
          // and markers/polyline update as geocodes return.

          for (let i = 0; i < stopsTotal; i++) {
            // nearest neighbor; if startTaluk provided, prefer same-taluk places first
            let bestIdx = -1;
            let bestDist = Infinity;
            if (startTaluk) {
              // try to find nearest within same taluk (only consider places with coordinates)
              unvisited.forEach((p, idx) => {
                if ((p.taluk || '').toLowerCase() === startTaluk.toLowerCase() && p.lat !== undefined && p.lng !== undefined) {
                  const d = kmDistance(cur.lat, cur.lng, p.lat, p.lng);
                  if (d < bestDist) { bestDist = d; bestIdx = idx; }
                }
              });
              // if none found in same taluk, pick nearest overall (with coords)
              if (bestIdx === -1) {
                unvisited.forEach((p, idx) => {
                  if (p.lat !== undefined && p.lng !== undefined) {
                    const d = kmDistance(cur.lat, cur.lng, p.lat, p.lng);
                    if (d < bestDist) { bestDist = d; bestIdx = idx; }
                  }
                });
              }
            } else {
              unvisited.forEach((p, idx) => {
                if (p.lat !== undefined && p.lng !== undefined) {
                  const d = kmDistance(cur.lat, cur.lng, p.lat, p.lng);
                  if (d < bestDist) { bestDist = d; bestIdx = idx; }
                }
              });
            }
            if (bestIdx === -1) break;
            const next = unvisited.splice(bestIdx, 1)[0];
            route.push(next);
            if (next.lat !== undefined && next.lng !== undefined) {
              cur = { lat: next.lat, lng: next.lng };
            }
          }

          // Build map modal
          const modal = document.getElementById('tripModal');
          modal.classList.remove('hidden');

          // initialize trip map
          let tripMap = L.map('trip-map', { scrollWheelZoom: true }).setView([startLatLng.lat, startLatLng.lng], 10);
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 20 }).addTo(tripMap);
          const layer = L.layerGroup().addTo(tripMap);

          // add start marker
          L.marker([startLatLng.lat, startLatLng.lng], { title: 'Start', icon: L.divIcon({ className: 'start-icon', html: '<div class="start-dot"></div>', iconSize: [14, 14], iconAnchor: [7, 7] }) }).addTo(layer).bindPopup('Start');

          // Do not block rendering waiting for geocoding. Instead, show the map immediately
          // with places that already have coordinates, then asynchronously resolve missing coords
          // and add markers/polyline segments as they arrive.

          const latlngs = [[startLatLng.lat, startLatLng.lng]];
          route.forEach((p, idx) => {
            if (p.lat !== undefined && p.lng !== undefined) {
              latlngs.push([p.lat, p.lng]);
              const icon = makeNumberedIcon(idx + 1);
              L.marker([p.lat, p.lng], { icon }).addTo(layer).bindPopup(`<strong>${p.name}</strong><div class='small'>${p.taluk} • ${p.type || ''}</div>`);
            }
          });

          let poly = null;
          if (latlngs.length > 1) {
            poly = L.polyline(latlngs, { color: '#0891b2', weight: 4, opacity: 0.9 }).addTo(layer);
            tripMap.fitBounds(poly.getBounds().pad(0.25));
          } else {
            tripMap.setView([startLatLng.lat, startLatLng.lng], 12);
          }

          // Asynchronously geocode any route items missing coordinates. When a geocode returns,
          // add a marker and rebuild the polyline so the map updates progressively without blocking.
          route.forEach((p, idx) => {
            if ((p.lat === undefined || p.lng === undefined) && p.name) {
              (async () => {
                try {
                  const q = encodeURIComponent((p.name || '') + (p.taluk ? ', ' + p.taluk : '') + ', Uttara Kannada, Karnataka, India');
                  const url = `https://nominatim.openstreetmap.org/search?format=json&limit=1&countrycodes=in&q=${q}`;
                  const res = await fetch(url, { headers: { 'Accept-Language': 'en' } });
                  const data = await res.json();
                  if (Array.isArray(data) && data.length > 0) {
                    p.lat = parseFloat(data[0].lat);
                    p.lng = parseFloat(data[0].lon);
                    p._geocoded = 'nominatim';
                    // add marker for this newly-resolved place
                    const icon = makeNumberedIcon(route.indexOf(p) + 1);
                    L.marker([p.lat, p.lng], { icon }).addTo(layer).bindPopup(`<strong>${p.name}</strong><div class='small'>${p.taluk} • ${p.type || ''}</div>`);
                    // rebuild polyline from available coordinates
                    try { if (poly) tripMap.removeLayer(poly); } catch (e) { }
                    const newLatlngs = [[startLatLng.lat, startLatLng.lng]];
                    route.forEach(pp => { if (pp.lat !== undefined && pp.lng !== undefined) newLatlngs.push([pp.lat, pp.lng]); });
                    if (newLatlngs.length > 1) {
                      poly = L.polyline(newLatlngs, { color: '#0891b2', weight: 4, opacity: 0.9 }).addTo(layer);
                      tripMap.fitBounds(poly.getBounds().pad(0.25));
                    }
                  }
                } catch (e) {
                  console.warn('Async geocode failed for', p.name, e);
                }
              })();
            }
          });
          // ensure Leaflet recalculates container size and renders tiles correctly
          setTimeout(() => { try { tripMap.invalidateSize(); } catch (e) { /* ignore */ } }, 200);

          // store last planned route so external actions (open in Google Maps) can use it
          window._lastPlanned = { start: startLatLng, route: route };
          // enable Go to map button (if present)
          const gbtn = document.getElementById('openGMapsBtn');
          if (gbtn) {
            gbtn.disabled = false;
          }

          // populate list grouped by day
          const perDay = Math.ceil(route.length / dayCount);
          const list = document.getElementById('trip-list');
          const grouped = [];
          for (let d = 0; d < dayCount; d++) {
            const start = d * perDay;
            const end = Math.min(start + perDay, route.length);
            if (start >= end) break;
            grouped.push(route.slice(start, end));
          }
          list.innerHTML = grouped.map((dayArr, di) => `
            <div style="padding:8px;border-bottom:1px solid #f1f5f9">
              <strong>Day ${di + 1}</strong>
              <div style="margin-top:6px">
                ${dayArr.map((p, pi) => `<div class="small">${(di * perDay + pi + 1)}. ${p.name} • ${p.taluk}</div>`).join('')}
              </div>
            </div>
          `).join('');

          document.getElementById('tripSummary').textContent = `${route.length} stops • ${dayCount} day${dayCount > 1 ? 's' : ''}`;

          // close handlers
          function closeTrip() { tripMap.remove(); modal.classList.add('hidden'); document.removeEventListener('keydown', tripEsc); tripCloseFn = null; }
          tripCloseFn = closeTrip;
          function tripEsc(e) { if (e.key === 'Escape') closeTrip(); }
          document.getElementById('tripClose').addEventListener('click', closeTrip);
          document.getElementById('tripBackdrop').addEventListener('click', closeTrip);
          document.getElementById('tripExitBtn').addEventListener('click', () => { if (typeof tripCloseFn === 'function') tripCloseFn(); else closeTrip(); });
          document.addEventListener('keydown', tripEsc);
        }

        // Planner runner used by both manual panel and quick plan
        async function runPlannerForPick(pick, dayCount) {
          if (!pick) return alert('Enter a start location (use Enter location or search box).');
          const numericMatch = pick.match(/(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)/);
          if (numericMatch) {
            planTripFrom({ lat: parseFloat(numericMatch[1]), lng: parseFloat(numericMatch[2]) }, dayCount);
            return;
          }

          let loc = null;
          const talukKey = Object.keys(placesData).find(k => k.toLowerCase() === pick.toLowerCase() || k.toLowerCase().includes(pick.toLowerCase()));
          if (talukKey) {
            const place = (placesData[talukKey] || []).find(pp => pp.lat && pp.lng);
            if (place) loc = { lat: place.lat, lng: place.lng };
          }
          if (!loc) {
            for (const tk of Object.keys(placesData)) {
              const found = (placesData[tk] || []).find(pp => pp.name && pp.name.toLowerCase().includes(pick.toLowerCase()) && pp.lat && pp.lng);
              if (found) { loc = { lat: found.lat, lng: found.lng }; break; }
            }
          }
          if (loc) { planTripFrom(loc, dayCount, talukKey); return; }

          try {
            const url = 'https://nominatim.openstreetmap.org/search?format=json&limit=1&countrycodes=in&q=' + encodeURIComponent(pick);
            const res = await fetch(url);
            const data = await res.json();
            if (data && data[0]) {
              planTripFrom({ lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) }, dayCount);
              return;
            }
            alert('Could not resolve start location for trip. Try a taluk name, place name, or lat,lng.');
          } catch (err) {
            console.warn(err);
            alert('Online geocoding failed while planning trip.');
          }
        }

        // Build Google Maps directions URL from planned route and open in new tab
        function openRouteInGoogleMaps(planned) {
          if (!planned || !planned.start) return alert('No planned route available.');
          const route = planned.route || [];
          if (route.length === 0) return alert('Planned route has no stops.');

          const coordOrName = (p) => {
            if (!p) return '';
            if (p.lat && p.lng) return `${p.lat},${p.lng}`;
            const label = (p.name || '') + (p.taluk ? ' ' + p.taluk : '');
            return encodeURIComponent(label);
          };

          const origin = `${planned.start.lat},${planned.start.lng}`;
          const destination = coordOrName(route[route.length - 1]);
          const waypoints = route.slice(0, -1).map(coordOrName).filter(Boolean);

          const params = new URLSearchParams({ api: '1', origin, destination, travelmode: 'driving' });
          if (waypoints.length) params.set('waypoints', waypoints.join('|'));
          const url = 'https://www.google.com/maps/dir/?' + params.toString();
          window.open(url, '_blank');
        }

        // wire Go to map button
        const openGMapsBtn = document.getElementById('openGMapsBtn');
        if (openGMapsBtn) {
          openGMapsBtn.addEventListener('click', () => {
            if (!window._lastPlanned) return alert('No planned route yet.');
            openRouteInGoogleMaps(window._lastPlanned);
          });
          // disabled until a route is planned
          openGMapsBtn.disabled = true;
        }

        // Quick plan from search box (click small label)
        const quickPlan = document.getElementById('planTripQuick');
        if (quickPlan) {
          quickPlan.addEventListener('click', () => {
            const dayCount = parseInt(document.getElementById('tripDays').value, 10) || 1;
            const pick = document.getElementById('search').value.trim();
            if (!pick) {
              // open manual panel to enter location
              document.getElementById('manualLocationPanel').classList.remove('hidden');
              document.getElementById('manualLocationInput').focus();
              return;
            }
            runPlannerForPick(pick, dayCount);
          });
        }

        // Nearby modal 'Plan trip' button — uses the modal's recorded start location
        const nearbyPlanBtn = document.getElementById('nearbyPlanBtn');
        if (nearbyPlanBtn) {
          nearbyPlanBtn.addEventListener('click', () => {
            if (!window._nearbyStartLatLng) return alert('No start location found for planning.');
            const dayCount = parseInt(document.getElementById('tripDays').value, 10) || 1;
            planTripFrom(window._nearbyStartLatLng, dayCount, window._nearbyStartTaluk);
            // close nearby modal after launching planner
            closeNearby();
          });
        }

        document.getElementById('findNearbyBtn').addEventListener('click', () => {
          const q = document.getElementById('search').value.trim().toLowerCase();
          let loc = null;
          if (q) {
            // match taluk key
            const talukKey = Object.keys(placesData).find(k => k.toLowerCase() === q || k.toLowerCase().includes(q));
            if (talukKey) {
              const place = (placesData[talukKey] || []).find(pp => pp.lat && pp.lng);
              if (place) loc = { lat: place.lat, lng: place.lng };
            }

            // match place name
            if (!loc) {
              for (const tk of Object.keys(placesData)) {
                const found = (placesData[tk] || []).find(pp => pp.name && pp.name.toLowerCase().includes(q) && pp.lat && pp.lng);
                if (found) { loc = { lat: found.lat, lng: found.lng }; break; }
              }
            }
          }
          if (loc) openNearbyModal(loc, talukKey); else alert('Location not found. Try a taluk name or use "Use my location".');
        });

        document.getElementById('nearbyClose').addEventListener('click', closeNearby);
        document.getElementById('nearbyBackdrop').addEventListener('click', closeNearby);
      })
      .catch(e => console.error(e));
  </script>
  <script>
    // Set current year in footer
    document.getElementById('currentYear').textContent = new Date().getFullYear();
  </script>
  <script src="js/dev.js"></script>
</body>

</html>